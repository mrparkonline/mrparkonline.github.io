<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction to Complexity &amp; Algorithms on Mr. Park's Site | mrparkonline</title><link>http://mrparkonline.github.io/courses/complexity/</link><description>Recent content in Introduction to Complexity &amp; Algorithms on Mr. Park's Site | mrparkonline</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 08 Aug 2020 14:27:32 -0400</lastBuildDate><atom:link href="http://mrparkonline.github.io/courses/complexity/index.xml" rel="self" type="application/rss+xml"/><item><title>Basic Sorting Algorithms</title><link>http://mrparkonline.github.io/courses/complexity/sorting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://mrparkonline.github.io/courses/complexity/sorting/</guid><description>Bubble Sort A sorting algorithm that is based upon comparing pairs of values and swapping their places if necessary
Overall Idea:
- (L→ List, i→ index, i starts at 1) - Look at L[i] and L[i-1] if they are not sorted, swap locations - Repeat as you increase i and until no swap occurs Bubble Sort Demonstration:
Source
Bubble Sort Algorithm Definition:
repeat until swapped is false swapped = false for i = 1 to N-1 (inclusively) if A[i-1] &amp;gt; A[i] then swap(A[i-1],A[i]) swapped = true Python Implementation:</description></item><item><title>Binary Search</title><link>http://mrparkonline.github.io/courses/complexity/binarysearch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://mrparkonline.github.io/courses/complexity/binarysearch/</guid><description>Binary Search A searching algorithm that is designed to search from a sorted list.
Idea:
Compare the target with the middle most value If not found, eliminate the half where the target cannot exist Cons/Caveat:
The database must be comparable and sortable Algorithm Let A be a sorted array; N be length of A; T be searching target 1. Set Left=0 and Right=N-1 2. while Left &amp;lt;= Right: 3.</description></item><item><title>Complexity Classification</title><link>http://mrparkonline.github.io/courses/complexity/complexityclassification/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://mrparkonline.github.io/courses/complexity/complexityclassification/</guid><description>Algorithm Complexity of Time &amp;amp; Space As computer scientists started to develop various algorithms for a solutions, they needed a way to classify the effectiveness of their algorithms, and they also required a way to prove that a new algorithm is better than the old by mathematical proof &amp;amp; analysis.
Image Source
Due to this, three notations methods were developed:
Big - O Notation (the worst case scenario) Big - Theta Notation (the average case scenario) Big- Omega Notation (the best case scenario) When we analyze an algorithm we can look at all three scenarios and see their effectiveness.</description></item><item><title>Linear Search</title><link>http://mrparkonline.github.io/courses/complexity/linear/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://mrparkonline.github.io/courses/complexity/linear/</guid><description>Linear Search Algorithm This algorithm is used for Strings and Lists often.
index() and find() are linear searches in and not in membership for strings and lists are linear searches Algorithm Classification Big-O: O(n) hence the name &amp;ldquo;Linear&amp;rdquo; Search &amp;hellip; happens when the target is not found -or- target is the last value Big-Omega: O(1) very first item is the target Big-Theta: O(n/2) which simplifies to O(n) &amp;hellip; target is found somewhere in the middle Linear Search Algorithm: # Let L be a list of items; i be the index, and N be the number of items # Let T be a Target 1 Set i to 0 2 If L at i == Target, then return i 3 Else increase i by 1 and repeat back to Line 2 4 If i &amp;gt; N, and target has not been found, then return -1 # Python Implementation def linSearch(seq, target): &amp;#39;&amp;#39;&amp;#39; linSearch determines the location of the target in the sequence -- param seq : iterable/indexable data target : any data -- return integer &amp;#39;&amp;#39;&amp;#39; if not seq: return -1 else: for i in range(len(seq)): if seq[i] == target: return i else: return -1 # end of linSearch # Example Execution from random import seed from random import randrange seed(1) seq = [randrange(1,100) for x in range(20)] print(&amp;#39;Random List:\n&amp;#39;, seq) print(&amp;#39;--\nSearch %din seq: Found at %d&amp;#39; % (18, linSearch(seq, 18))) print(&amp;#39;Search %din seq: Found at %d&amp;#39; % (61, linSearch(seq, 61))) print(&amp;#39;Search %din seq: Found at %d&amp;#39; % (42, linSearch(seq, 42))) Random List: [18, 73, 98, 9, 33, 16, 64, 98, 58, 61, 84, 49, 27, 13, 63, 4, 50, 56, 78, 98] -- Search 18 in seq: Found at 0 Search 61 in seq: Found at 9 Search 42 in seq: Found at -1 Python 3 Note #Method 2 def linSearch(seq, target): ctr = 0 while ctr &amp;lt; len(array): if array[ctr] == target: return ctr ctr += 1 else: return -1 Some of you may want to use a while loop with a counter rather than coding a for loop.</description></item><item><title>Merge Sort</title><link>http://mrparkonline.github.io/courses/complexity/merge/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://mrparkonline.github.io/courses/complexity/merge/</guid><description>Merge Sort A comparison-based algorithm that sorts a given dataset.
It is classified as a “divide and conquer” algorithm
There are 2 approaches to implementing a merge sort:
Top-Down Implementation Bottom-Up Implementation Merge Sort Demonstration:
Source
Complexity of Merge Sort:
$O(n log n)$ Worst Case Performance $O(n log n)$ Average Case Performance $O(n log n)$ Best Case Performance Merge Sort Algorithm:
-- Let A be an unsorted list, n represent size of A function: divider(A) Create two empty lists called Left and Right Get Midpoint at n/2 - 1, - all values before and include the midpoint is Left list - all values after midpoint is Right list Update Left to divider(Left) .</description></item><item><title>Recursion</title><link>http://mrparkonline.github.io/courses/complexity/recursion/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://mrparkonline.github.io/courses/complexity/recursion/</guid><description>Recursion Recursion: a method to solve computational problem by relying on smaller instances of a solution to a given problem.
The logic is that if we have a base case that helps to solves the smaller instance, then the base case solution helps to solve the bigger version of the solution.
*Example of a common recursive function: Fibonacci Number
$fib(n)= fib(n-1) + fib(n-2)$
$fib(0) = 0$
$fib(1) = 1$</description></item><item><title>Run Time Analysis</title><link>http://mrparkonline.github.io/courses/complexity/runtime/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://mrparkonline.github.io/courses/complexity/runtime/</guid><description>Runtime Analysis Simple Runtime Calculation with Python 3 When we are creating a solution for a problem we can be hindered by the efficency of our solution. A more efficient and well optimized code will run and solve the problem much faster than a less efficient code.
There are mathematical proofs / analysis you can do to your code to see the theoretical classification of your solution. Currently this method is beyond the scope of the course, so we will only learn the classification not the proofs We will use a built-in python module to help us calculate the runtime of our code.</description></item></channel></rss>