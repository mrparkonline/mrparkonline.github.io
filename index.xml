<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Mr. Park's Website on Mr. Park's Site | mrparkonline</title><link>http://mrparkonline.github.io/</link><description>Recent content in Mr. Park's Website on Mr. Park's Site | mrparkonline</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 09 Aug 2020 10:49:24 -0400</lastBuildDate><atom:link href="http://mrparkonline.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>About</title><link>http://mrparkonline.github.io/about/</link><pubDate>Sat, 08 Aug 2020 14:14:58 -0400</pubDate><guid>http://mrparkonline.github.io/about/</guid><description>This about.md</description></item><item><title>Example</title><link>http://mrparkonline.github.io/guides/example/</link><pubDate>Fri, 07 Aug 2020 17:33:13 -0400</pubDate><guid>http://mrparkonline.github.io/guides/example/</guid><description>Markdown is fully supported So are a variety of other flavors If you prefer certain flavors, you should check it out on the official documentation.</description></item><item><title>Basic Sorting Algorithms</title><link>http://mrparkonline.github.io/courses/complexity/sorting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://mrparkonline.github.io/courses/complexity/sorting/</guid><description>Bubble Sort A sorting algorithm that is based upon comparing pairs of values and swapping their places if necessary
Overall Idea:
- (L→ List, i→ index, i starts at 1) - Look at L[i] and L[i-1] if they are not sorted, swap locations - Repeat as you increase i and until no swap occurs Bubble Sort Demonstration:
Source
Bubble Sort Algorithm Definition:
repeat until swapped is false swapped = false for i = 1 to N-1 (inclusively) if A[i-1] &amp;gt; A[i] then swap(A[i-1],A[i]) swapped = true Python Implementation:</description></item><item><title>Binary Search</title><link>http://mrparkonline.github.io/courses/complexity/binarysearch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://mrparkonline.github.io/courses/complexity/binarysearch/</guid><description>Binary Search A searching algorithm that is designed to search from a sorted list.
Idea:
Compare the target with the middle most value If not found, eliminate the half where the target cannot exist Cons/Caveat:
The database must be comparable and sortable Algorithm Let A be a sorted array; N be length of A; T be searching target 1. Set Left=0 and Right=N-1 2. while Left &amp;lt;= Right: 3.</description></item><item><title>Complexity Classification</title><link>http://mrparkonline.github.io/courses/complexity/complexityclassification/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://mrparkonline.github.io/courses/complexity/complexityclassification/</guid><description>Algorithm Complexity of Time &amp;amp; Space As computer scientists started to develop various algorithms for a solutions, they needed a way to classify the effectiveness of their algorithms, and they also required a way to prove that a new algorithm is better than the old by mathematical proof &amp;amp; analysis.
Image Source
Due to this, three notations methods were developed:
Big - O Notation (the worst case scenario) Big - Theta Notation (the average case scenario) Big- Omega Notation (the best case scenario) When we analyze an algorithm we can look at all three scenarios and see their effectiveness.</description></item><item><title>Dictionary</title><link>http://mrparkonline.github.io/courses/datastruct/dictionary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://mrparkonline.github.io/courses/datastruct/dictionary/</guid><description>Dictionary in Python 3 Dictionary (Associative Array, map, symbol table) is a data type that stores a collection of (key, value) pairs, such that each possible key appears at most once in the collection.
Common Operations:
Adding a pair Removing a pair Modify an existing pair Lookup of a value associated with a particular key Aside: This concept is an introduction to concepts similar to: hash table and search trees</description></item><item><title>Linear Search</title><link>http://mrparkonline.github.io/courses/complexity/linear/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://mrparkonline.github.io/courses/complexity/linear/</guid><description>Linear Search Algorithm This algorithm is used for Strings and Lists often.
index() and find() are linear searches in and not in membership for strings and lists are linear searches Algorithm Classification Big-O: O(n) hence the name &amp;ldquo;Linear&amp;rdquo; Search &amp;hellip; happens when the target is not found -or- target is the last value Big-Omega: O(1) very first item is the target Big-Theta: O(n/2) which simplifies to O(n) &amp;hellip; target is found somewhere in the middle Linear Search Algorithm: # Let L be a list of items; i be the index, and N be the number of items # Let T be a Target 1 Set i to 0 2 If L at i == Target, then return i 3 Else increase i by 1 and repeat back to Line 2 4 If i &amp;gt; N, and target has not been found, then return -1 # Python Implementation def linSearch(seq, target): &amp;#39;&amp;#39;&amp;#39; linSearch determines the location of the target in the sequence -- param seq : iterable/indexable data target : any data -- return integer &amp;#39;&amp;#39;&amp;#39; if not seq: return -1 else: for i in range(len(seq)): if seq[i] == target: return i else: return -1 # end of linSearch # Example Execution from random import seed from random import randrange seed(1) seq = [randrange(1,100) for x in range(20)] print(&amp;#39;Random List:\n&amp;#39;, seq) print(&amp;#39;--\nSearch %din seq: Found at %d&amp;#39; % (18, linSearch(seq, 18))) print(&amp;#39;Search %din seq: Found at %d&amp;#39; % (61, linSearch(seq, 61))) print(&amp;#39;Search %din seq: Found at %d&amp;#39; % (42, linSearch(seq, 42))) Random List: [18, 73, 98, 9, 33, 16, 64, 98, 58, 61, 84, 49, 27, 13, 63, 4, 50, 56, 78, 98] -- Search 18 in seq: Found at 0 Search 61 in seq: Found at 9 Search 42 in seq: Found at -1 Python 3 Note #Method 2 def linSearch(seq, target): ctr = 0 while ctr &amp;lt; len(array): if array[ctr] == target: return ctr ctr += 1 else: return -1 Some of you may want to use a while loop with a counter rather than coding a for loop.</description></item><item><title>Map &amp; Filter</title><link>http://mrparkonline.github.io/courses/datastruct/map/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://mrparkonline.github.io/courses/datastruct/map/</guid><description>Map &amp;amp; Filter In Python 3 In this note, we will be covering some useful built-in functions to help us extend our list comprehension capabilities.
These two functions that we learn will also be revisited when we do functional programming and lambda functions.
The Map Function The idea of a map function is to apply a function to an iterable data.
Formatting: map(function_name, sequence) -- function_name: any function (built-in or selfmade) that returns a desired value of choice -- sequence: any iterable data type # Example def square(num): &amp;#39;&amp;#39;&amp;#39; squares the given num argument &amp;#39;&amp;#39;&amp;#39; return num ** 2 # end of square array = list(range(1,11)) square_array = list(map(square, array)) print(&amp;#39;Original Array:&amp;#39;, array) print(&amp;#39;Array Squared:&amp;#39;, square_array) Original Array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] Array Squared: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] One thing to note about the map function is that it doesn&amp;rsquo;t return a specific data type, but rather, an python iterable data.</description></item><item><title>Matrices &amp; List Comprehension</title><link>http://mrparkonline.github.io/courses/datastruct/matrices/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://mrparkonline.github.io/courses/datastruct/matrices/</guid><description>Matrices in Python 3 What is a Matrix? Mathematically, matrix is a representations of numbers, symbols, or expressions in a 2-Dimensional Array.
In Computer Science, especially with Python, we can start to create a data structure that has values in rows and columns, much like a table, by utilizing a list within a list. There are external libraries/modules that can be imported into your python program to help this process; however, we will be constructing them with just the standalone python version.</description></item><item><title>Merge Sort</title><link>http://mrparkonline.github.io/courses/complexity/merge/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://mrparkonline.github.io/courses/complexity/merge/</guid><description>Merge Sort A comparison-based algorithm that sorts a given dataset.
It is classified as a “divide and conquer” algorithm
There are 2 approaches to implementing a merge sort:
Top-Down Implementation Bottom-Up Implementation Merge Sort Demonstration:
Source
Complexity of Merge Sort:
$O(n log n)$ Worst Case Performance $O(n log n)$ Average Case Performance $O(n log n)$ Best Case Performance Merge Sort Algorithm:
-- Let A be an unsorted list, n represent size of A function: divider(A) Create two empty lists called Left and Right Get Midpoint at n/2 - 1, - all values before and include the midpoint is Left list - all values after midpoint is Right list Update Left to divider(Left) .</description></item><item><title>Recursion</title><link>http://mrparkonline.github.io/courses/complexity/recursion/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://mrparkonline.github.io/courses/complexity/recursion/</guid><description>Recursion Recursion: a method to solve computational problem by relying on smaller instances of a solution to a given problem.
The logic is that if we have a base case that helps to solves the smaller instance, then the base case solution helps to solve the bigger version of the solution.
*Example of a common recursive function: Fibonacci Number
$fib(n)= fib(n-1) + fib(n-2)$
$fib(0) = 0$
$fib(1) = 1$</description></item><item><title>Run Time Analysis</title><link>http://mrparkonline.github.io/courses/complexity/runtime/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://mrparkonline.github.io/courses/complexity/runtime/</guid><description>Runtime Analysis Simple Runtime Calculation with Python 3 When we are creating a solution for a problem we can be hindered by the efficency of our solution. A more efficient and well optimized code will run and solve the problem much faster than a less efficient code.
There are mathematical proofs / analysis you can do to your code to see the theoretical classification of your solution. Currently this method is beyond the scope of the course, so we will only learn the classification not the proofs We will use a built-in python module to help us calculate the runtime of our code.</description></item><item><title>Sets</title><link>http://mrparkonline.github.io/courses/datastruct/sets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://mrparkonline.github.io/courses/datastruct/sets/</guid><description>Sets in Python 3 A set is an unordered collection with no duplicate elements in Python 3.
Set is a mathematical way to describe collection of different unique objects.
By following the operations and characteristics of the mathematical set, we can utilizie such data structure in our Python code.
The mathematical definition of the set can read in more details here.
Using Sets in Python 3 How to Define a Set</description></item><item><title>Tuples</title><link>http://mrparkonline.github.io/courses/datastruct/tuples/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://mrparkonline.github.io/courses/datastruct/tuples/</guid><description>Tuples in Python 3 What are Tuples? Strings and Lists are basic iterable data types that are very similar with key differences:
Strings only allow alphanumeric characters and special symbols to represent text Lists allow all data types as its items/members Strings are immutable whereas Lists are mutable These significant differences cause a headache when you require the following data structure:
It must be immutable It must allow different datatypes as items It must be iterable It must be nestable (much like a list within a list) All of these are solved with a data structure called: Tuple.</description></item></channel></rss>